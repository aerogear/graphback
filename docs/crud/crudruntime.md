---
id: crudruntime
title: CRUD Runtime abstraction
sidebar_label: CRUD Abstraction
---

## Graphback CRUD Abstraction

Graphback CRUD abstraction available as part of the @graphback/runtime package provides a way to programatically define different datasources and configure them without code generation.

Runtime is abstracted into two interfaces:

- `GraphbackCRUDService` - layer that wraps data provider, can implement custom behaviour like subscriptions or live queries
- `GraphbackDataProvider` - data access layer 

### GraphbackCRUDService

Graphback provides following implementations of GraphbackCRUDService

- `CRUDService` - implements subscriptions and logging. Used by default in resolver generator.

### GraphbackDataProvider

Graphback provides following implementations of GraphbackDataProvider

- KnexDBDataProvider (`@graphback/runtime-knex`)
- PgKnexDBDataProvider (PostgreSQL version from `@graphback/runtime-knex`)
- MongoDBDataProvider (`@graphback/runtime-mongodb`)

Your resolvers can use different data providers thanks to swapping implementation in resolver context

![](/img/runtime.png)

## Adding custom resolvers to runtime

Runtime layer will come with autogenerated schema that will also include custom resolvers provided in model.
Developers can append their custom resolvers to resolver array to extend runtime layer.

## How Runtime relates to the resolvers

Graphback resolver generator plugin generates resolvers that utilize one of the preconfigured `GraphbackCRUDService` implementations.
`GraphbackCRUDService` implementation is using `GraphbackDataProvider`.

![](/img/runtime.png)

Instances need to be added to `context` object in resolver for example:

```js
findAllComments: (parent, args, context) => {
  // Comment is an implementation of `GraphbackCRUDService` 
  return context.Comment.findAll();
};
```

## Modifying implementation

Graphback plugin will generate `createContext.ts` file that creates instances of your model.
Developers can modify them and point them to the different datasources without using code generation.

To use runtime developers need to call `createCRUDResolversRuntimeContext` from `createContext.ts` when creating their GraphQL Server:

```ts
   const context = createCRUDResolversRuntimeContext({ schema, db, pubSub });
    const apolloServer = new ApolloServer({
        typeDefs: typeDefs,
        resolvers,
        context,
        playground: true,
    })
```

## Why we need CRUD Abstraction

Code generators produce a large amount of the code that needs to be maintained later.
Having generator code diverging from original form will prevent developers to utilize generators.
Graphback tries to address many challenging issues like data caching, batching, consistency etc. that will be hard to implement and test by utilizing only code generation.
That is why our default resolver generators rely on CRUD abstraction layer that can be used to connect Graphback to any datasource without writing generator plugin.