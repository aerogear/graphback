---
id: crudruntime
title: CRUD Runtime Abstraction
sidebar_label: CRUD Abstraction
---

A Graphback CRUD abstraction is available as part of the `@graphback/runtime` package, providing a way to programatically define different datasources and configure them without code generation.

Runtime is abstracted into two interfaces:

- `GraphbackCRUDService`: layer that wraps data provider, can implement custom behaviour like subscriptions or live queries
- `GraphbackDataProvider`: data access layer 

### GraphbackCRUDService

Graphback provides the following implementations of `GraphbackCRUDService`

- `CRUDService`: implements subscriptions and logging. Used by default in resolver generator

### GraphbackDataProvider

Graphback provides the following implementations of `GraphbackDataProvider`:

- [`PgKnexDBDataProvider`](https://www.npmjs.com/package/@graphback/runtime-knex): PostgreSQL data provider using [Knex.js](http://knexjs.org/)
- [`MongoDBDataProvider`](https://www.npmjs.com/package/@graphback/runtime-mongo): Data provider for MongoDB
- [`KnexDBDataProvider`](https://www.npmjs.com/package/@graphback/runtime-knex): Data provider using [Knex.js](http://knexjs.org/)

Your resolvers can use any of these data providers by swapping the implementation and attaching it to your application context. See [Data Sources](../db/datasources) to learn how.

![](/img/runtime.png)

## Adding custom resolvers to runtime

Runtime layer will come with autogenerated schema that will also include custom resolvers provided in model.
Developers can append their custom resolvers to resolver array to extend runtime layer.

## How Runtime relates to the resolvers 

Graphback resolver generator plugin generates resolvers that utilize one of the preconfigured `GraphbackCRUDService` implementations.
`GraphbackCRUDService` implementation is using `GraphbackDataProvider`.

![](/img/runtime.png)

Instances need to be added to `context` object in resolver for example:

```js
findComments: (parent, args, context) => {
  // Comment is an implementation of `GraphbackCRUDService` 
  return context.Comment.find();
};
```

## Why we need CRUD Abstraction

Code generators produce a large amount of the code that needs to be maintained later.
Having generator code diverging from original form will prevent developers from utilizing generators.
Graphback tries to address many challenging issues like data caching, batching, consistency etc. that will be hard to implement and test by utilizing only code generation.
That is why our default resolver generators rely on CRUD abstraction layer that can be used to connect Graphback to any datasource without writing generator plugin.
