---
title: Graphback - the evolution of the GraphQL ecosystem
tags: graphql, nodejs
author: Wojciech Trocki
authorURL: http://twitter.com/typeapi
authorFBID: 2026021350761623

---

GraphQL was created almost 7 years ago at Facebook to resolve specific problems for the Facebook mobile platform. As Query Language, GraphQL offers transport and data exchange layer between server and client, leaving many implementation details to developers. 
When comparing with REST, GraphQL technology has a steep learning curve and many pitfalls waiting for beginner developers looking to embrace it.

<!--truncate-->

## GraphQL ecosystem in 2019

Over the years the ecosystem flourished and evolved towards more production-ready use cases. GraphQL stack became more mature and more developers started to create their applications using this technology. 

GraphQL evolved thanks to the large community and many supporting libraries. Choosing the right approach in the ocean of the options can be not only overwhelming but also lead to building solutions that will be suboptimal to our domain and our business needs. 

![graphql logo](https://thepracticaldev.s3.amazonaws.com/i/wyo0ouclmymj2cfou7e7.png)

Writing a GraphQL application that is secure and performant can still be a challenging task that involves many technical decisions and architecture patterns that need to be applied.

## Challenge of building on top of sample apps 

GraphQL community offers many example apps and approaches that can be used as a starting point for your project. Quality of those may differ and they can often be outdated. There are very few sample apps that will cover production-ready use cases due to the complexity of the applications. 

Covering complex use cases will often require writing a lot of business logic that needs to be later manually removed by developers who want to reuse sample application for their needs.

## Sample apps working with your business logic

If you ever worked with simple sample application you may recall how hard is to adjust those to real business cases. 

As an alternative to sample apps, developers can rely on frameworks that provide a high level of abstraction. Technologies that offer rapid application development often come at the cost of the maintenance and flexibility that can seriously limit the extensibility of your application server. 

Over the years our team focused on developing scalable GraphQL based servers and clients and we are often were asking ourselves:

> Can we build an application template that can offer production-ready capabilities and yet is simple enough to work with without extensive learning?

> Can we provide our data model as input to the GraphQL engine and benefit autogenerated data access methods?

Answers for these questions led us to the creation of the new GraphQL based ecosystem called Graphback.

## Introducing Graphback

![Alt Text](https://thepracticaldev.s3.amazonaws.com/i/b58zov9fctzk44qzwrln.png)

The target of Graphback is to make sample applications working with your business logic by utilizing application templates and code generation. Developers can provide GraphQL schema as input and the command-line client will generate data access methods on top of the chosen stack (called template) and databases we support. 

Graphback generates Node.JS application with an entire codebase that is editable and can be later deployed to your own server or cloud provider.
By default, Graphback will follow the best patterns and include proven open-source libraries provided by the vibrant GraphQL community. When working with relational databases Graphback will allow users to manage database schema. The real power of Graphback is its code generation engine that can be extended for different needs. 

![diagram](https://thepracticaldev.s3.amazonaws.com/i/c9q6rvbb9v534073cq6j.png)


## Graphback to resolve major issues in GraphQL community

Graphback helps developers to boost their getting started experience with GraphQL. The Graphback CLI offers different workflows supporting data retrieval from the database and REST endpoints.
Templates allow having different flavors of the GraphQL frameworks like Relay, Apollo, and Prisma for database access. Thanks to templates developers can avail of a fully functional set of libraries that produce business value and work really well together. The community can provide their own templates to contribute to the success of the entire GraphQL ecosystem.

Graphback generated application source code will be always in your full control - no hidden dependencies or any additional limitations included from Graphback runtime. Graphback will generate CRUD data access methods that can be extended into more customized data access functions at any time.

Developers can introduce custom queries and mutations that will generate data access stubs. Thanks to first-class TypeScript support, generated projects offer type safety.

## Ecosystem of templates

Graphback builds an ecosystem for developers that can build sample apps as templates that can be extended by additional features and business logic. Graphback templates follow canonical implementations and allow developers to continue development in a traditional way and tweak every aspect of the application.

![Alt Text](https://thepracticaldev.s3.amazonaws.com/i/ss0zueqh885m8h5wra1y.gif)

## Not just a GraphQL server

Apart from fully functional back-end server, developers can choose to generate GraphQL queries for client-side applications. Client-side code can utilize form generators like https://uniforms.tools, giving developers end to end front-end and back-end solutions that will rely on their schema. 

## Support 

Our project is maintained by volunteers who are devoted to constant love and maintenance. 
You can support us by becoming a [Graphback stargazer](https://github.com/aerogear/graphback/stargazers) on GitHub, or by sharing it on social media.


Our GitHub: 
https://github.com/aerogear/graphback/

Our website: 
http://graphback.dev




