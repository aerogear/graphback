(window.webpackJsonp=window.webpackJsonp||[]).push([[941],{1083:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),b=p(n),m=r,u=b["".concat(c,".").concat(m)]||b[m]||d[m]||o;return n?a.a.createElement(u,s(s({ref:t},l),{},{components:n})):a.a.createElement(u,s({ref:t},l))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,c[1]=s;for(var l=2;l<o;l++)c[l]=n[l];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},997:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return p}));var r=n(2),a=n(6),o=(n(0),n(1083)),c={id:"custom-resolvers",title:"Using Graphback in custom resolvers",sidebar_label:"Custom Resolvers"},s={unversionedId:"resolvers/custom-resolvers",id:"version-0.16.x/resolvers/custom-resolvers",isDocsHomePage:!1,title:"Using Graphback in custom resolvers",description:"The model CRUD services created by Graphback are exposed to each resolver through the context parameter. Thanks to the flexible CRUD API, you can reuse these services for various use cases in your own resolvers.",source:"@site/versioned_docs/version-0.16.x/resolvers/custom-resolvers.md",slug:"/resolvers/custom-resolvers",permalink:"/docs/resolvers/custom-resolvers",editUrl:"https://github.com/aerogear/graphback/edit/master/website/versioned_docs/version-0.16.x/resolvers/custom-resolvers.md",version:"0.16.x",sidebar_label:"Custom Resolvers",sidebar:"version-0.16.x/docs",previous:{title:"Subscriptions",permalink:"/docs/crud/subscriptions"},next:{title:"Overview",permalink:"/docs/databases/overview"}},i=[{value:"context",id:"context",children:[]},{value:"info",id:"info",children:[]},{value:"Usage Of <code>GraphQLResolveInfo</code>",id:"usage-of-graphqlresolveinfo",children:[]},{value:"Retrieving Nested Fields From <code>GraphQLResolveInfo</code>",id:"retrieving-nested-fields-from-graphqlresolveinfo",children:[]}],l={rightToc:i};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The model CRUD services created by Graphback are exposed to each resolver through the ",Object(o.b)("inlineCode",{parentName:"p"},"context")," parameter. Thanks to the flexible CRUD API, you can reuse these services for various use cases in your own resolvers."),Object(o.b)("p",null,"In this example, we are going to create a custom query called ",Object(o.b)("inlineCode",{parentName:"p"},"getDraftNotes"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),'import { QueryFilter, GraphbackContext, buildGraphbackAPI } from "graphback";\nimport { GraphQLResolveInfo } from \'graphql\';\nimport { NoteFilter } from \'../generated-types\'; // https://graphql-code-generator.com\n\n// define your model\nconst model = `\n""" @model """\ntype Note {\n  id: ID!\n  title: String!\n}\n\n// highlight-start\ntype Query {\n  getDraftNotes: [Note]\n}\n// highlight-end\n`;\n\n// create your own custom resolvers\nconst customResolvers = {\n  Query: {\n    getDraftNotes: async (parent: any, args: any, context: GraphbackContext, info: GraphQLResolveInfo) => {\n      const filter: QueryFilter<NoteFilter> = {\n        title: {\n          startsWith: \'[DRAFT]\'\n        }\n      }\n\n      const results = await context.graphback.Note.findBy({ filter }, context, info);\n\n      return results.items;\n    }\n  }\n}\n\n// generate Graphback schema and resolvers\nconst { resolvers, typeDefs, contextCreator } = buildGraphbackAPI(model, { ... });\n\nconst apolloServer = new ApolloServer({\n  typeDefs,\n  resolvers: [resolvers, noteResolvers], // merge Graphback and custom resolvers\n  context: contextCreator\n})\n')),Object(o.b)("p",null,"See the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../api/graphback-core/interfaces/_runtime_graphbackcrudservice_.graphbackcrudservice"}),"GraphbackCRUDService API Reference")," for information on the methods and parameters available in the ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackCRUDService")," interface."),Object(o.b)("h3",{id:"context"},"context"),Object(o.b)("p",null,"The ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../api/graphback-core/interfaces/_runtime_interfaces_.graphbackcontext"}),"GraphbackContext")," interface defines all CRUD services in the ",Object(o.b)("inlineCode",{parentName:"p"},"graphback")," property. Each service name matches exactly with the name of the model defined in your GraphQL schema."),Object(o.b)("p",null,"Accessing the CRUD service for the ",Object(o.b)("inlineCode",{parentName:"p"},"Note")," model:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"await context.graphback.Note.findBy(args);\n")),Object(o.b)("p",null,"Because the services and context are create at runtime the properties of ",Object(o.b)("inlineCode",{parentName:"p"},"graphback")," are dynamically typed. It is recommended that you extend ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackContext")," for your resolvers to provide strongly typed services."),Object(o.b)("p",null,"You can optionally pass the ",Object(o.b)("inlineCode",{parentName:"p"},"Note")," type generated with ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://graphql-code-generator.com/"}),"GraphQL Code Generator")," as a generic to ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackCRUDService")," for additional type-safety."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import { GraphbackContext, GraphbackCRUDService } from 'graphback';\nimport { Note } from './generated-types';\n\ninterface MyCustomContext extends GraphbackContext {\n  graphback: {\n    Note: GraphbackCRUDService<Note>\n  }\n}\n\nconst customResolvers = {\n  Query: {\n    // highlight-start\n    getDraftNotes: async (parent: any, args: any, context: MyCustomContext, info: GraphQLResolveInfo) => {\n    // highlight-end\n      ...\n    }\n  }\n}\n")),Object(o.b)("p",null,"Each ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackCRUDService")," method lets you pass the context as a parameter, as some implementations may use the context in its operations."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"await context.Note.findBy(args, context);\n")),Object(o.b)("h3",{id:"info"},"info"),Object(o.b)("p",null,"The optional ",Object(o.b)("inlineCode",{parentName:"p"},"GraphQLResolveInfo")," object is available to every resolver and contains information about the GraphQL schema and the current operation.\nYou can optionally pass this to the ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackCRUDService")," method. A common use for this parameter is mapping the selected fields from the GraphQL query to the database query. "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"await context.Note.findBy(args, context, info);\n")),Object(o.b)("h3",{id:"usage-of-graphqlresolveinfo"},"Usage Of ",Object(o.b)("inlineCode",{parentName:"h3"},"GraphQLResolveInfo")),Object(o.b)("p",null,"When using the built an implementation of the ",Object(o.b)("inlineCode",{parentName:"p"},"GraphbackCRUDService")," interface, such as ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/graphback-core/classes/_runtime_crudservice_.crudservice"}),"CRUDService"),", Graphback will use the ",Object(o.b)("inlineCode",{parentName:"p"},"info")," object to map the selected fields from the GraphQL query to the database query. If the requested fields from the GraphQL query are not contained by the ",Object(o.b)("inlineCode",{parentName:"p"},"model")," held by the service in question, then an empty selection of fields will be sent to the database. For example, if the GraphQL query contains the ",Object(o.b)("inlineCode",{parentName:"p"},"Note")," model informations, passing the ",Object(o.b)("inlineCode",{parentName:"p"},"info")," into a"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"await context.Comment.findBy(args, context, info)\n")),Object(o.b)("p",null," will likely return false results or crash in a relational database. "),Object(o.b)("p",null,"In order to avoid such cases, we recommend to pass the ",Object(o.b)("inlineCode",{parentName:"p"},"info")," object only when the fields requested by the incoming GraphQL query are contained by the model. "),Object(o.b)("h3",{id:"retrieving-nested-fields-from-graphqlresolveinfo"},"Retrieving Nested Fields From ",Object(o.b)("inlineCode",{parentName:"h3"},"GraphQLResolveInfo")),Object(o.b)("p",null,"If you want to retrieve nested selected fields from the GraphQL query to the database query, you can optionally pass the ",Object(o.b)("inlineCode",{parentName:"p"},"nested path")," as an argument to the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"../api/core/classes/_runtime_crudservice_.crudservice.md#findby"}),Object(o.b)("inlineCode",{parentName:"a"},"findBy"))," method. "),Object(o.b)("p",null,"For example:"),Object(o.b)("p",null,"If the incoming query is: "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"\nquery {\n  getDraftNotes {\n    comments {\n      id, \n      description\n    }\n  }\n}\n")),Object(o.b)("p",null,"And somewhere in your custom resolvers, you'd like to map the ",Object(o.b)("inlineCode",{parentName:"p"},"id")," and ",Object(o.b)("inlineCode",{parentName:"p"},"description")," fields for the ",Object(o.b)("inlineCode",{parentName:"p"},"Comment")," model to the underlying database query, you achieve that with:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"\n// retrieve all notes using incoming args and info\nconst { items: allNotes } = await context.Notes.findBy(args, context, info);\n\nconst noteIds = allNotes.map(({ id }) => id);\n\n// retrieves comments owned by notes selected above. Specifying the \"comments\" path so start selection\nconst { items: comments } = await context.Comment.findBy({noteId: {in: noteIds}}, context, info, 'comments');\n\n// ... do the rest\n")))}p.isMDXComponent=!0}}]);