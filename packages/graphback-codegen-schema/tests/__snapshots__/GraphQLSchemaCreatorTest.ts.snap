// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test one side relationship schema query type generation 1`] = `
"\\"\\"\\" @model \\"\\"\\"
type Note {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@oneToMany field: 'note', key: 'test_id'\\"\\"\\"
  tests: [Test]!
}

input NoteInput {
  id: ID
  title: String
  description: String
}

type Query {
  findAllNotes(limit: Int, offset: Int): [Note]!
  findNotes(fields: NoteInput, limit: Int, offset: Int): [Note]!
  findAllTests(limit: Int, offset: Int): [Test]!
  findTests(fields: TestInput, limit: Int, offset: Int): [Test]!
}

\\"\\"\\"@model\\"\\"\\"
type Test {
  id: ID!
  name: String

  \\"\\"\\"@manyToOne field: 'tests', key: 'test_id'\\"\\"\\"
  note: Note
}

input TestInput {
  id: ID
  name: String
  test_id: ID
}
"
`;

exports[`Test snapshot config gql 1`] = `
"directive @test(description: String) on FIELD_DEFINITION | ENUM_VALUE

\\"\\"\\" @model \\"\\"\\"
type Comment {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@manyToOne field: 'comments', key: 'note_id'\\"\\"\\"
  noteComment: Note!
}

input CommentFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [CommentFilterInput]
  or: [CommentFilterInput]
  not: [CommentFilterInput]
}

input CommentInput {
  id: ID
  title: String
  description: String
}

type CommentListResult {
  items: [Comment]!
  nextCursor: String
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID]
  contains: ID
  startsWith: ID
  endsWith: ID
}

type Mutation {
  likeNote(id: ID!): Note!
  createNote(input: NoteInput!): Note!
  updateNote(input: NoteInput!): Note!
  deleteNote(input: NoteInput!): Note!
  createComment(input: CommentInput!): Comment!
  updateComment(input: CommentInput!): Comment!
  deleteComment(input: CommentInput!): Comment!
  createTest(input: TestInput!): Test!
  updateTest(input: TestInput!): Test!
  deleteTest(input: TestInput!): Test!
}

\\"\\"\\" @model \\"\\"\\"
type Note {
  id: ID!
  title: String! @test(description: \\"mock directive\\")
  description: String!

  \\"\\"\\"@oneToMany field: 'noteComment', key: 'note_id'\\"\\"\\"
  comments(filter: CommentFilterInput): [Comment]!

  \\"\\"\\"@oneToOne key: 'test_id'\\"\\"\\"
  test: Test
}

input NoteFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [NoteFilterInput]
  or: [NoteFilterInput]
  not: [NoteFilterInput]
}

input NoteInput {
  id: ID
  title: String
  description: String
}

type NoteListResult {
  items: [Note]!
  nextCursor: String
}

type Query {
  getLikedNotes(id: ID!, names: [String]!): Note!
  findNote(id: ID!): Note
  findNotes(filter: NoteFilterInput, limit: Int, offset: Int): NoteListResult!
  findAllNotes(filter: NoteFilterInput, limit: Int, offset: Int): [Note!]
  findComment(id: ID!): Comment
  findComments(filter: CommentFilterInput, limit: Int, offset: Int): CommentListResult!
  findAllComments(filter: CommentFilterInput, limit: Int, offset: Int): [Comment!]
  findTest(id: ID!): Test
  findTests(filter: TestFilterInput, limit: Int, offset: Int): TestListResult!
  findAllTests(filter: TestFilterInput, limit: Int, offset: Int): [Test!]
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newNote(input: NoteInput): Note!
  updatedNote(input: NoteInput): Note!
  deletedNote(input: NoteInput): Note!
  newComment(input: CommentInput): Comment!
  updatedComment(input: CommentInput): Comment!
  deletedComment(input: CommentInput): Comment!
  newTest(input: TestInput): Test!
  updatedTest(input: TestInput): Test!
  deletedTest(input: TestInput): Test!
}

\\"\\"\\"@model\\"\\"\\"
type Test {
  id: ID!
  name: String
}

input TestFilterInput {
  id: IDInput
  name: StringInput
  and: [TestFilterInput]
  or: [TestFilterInput]
  not: [TestFilterInput]
}

input TestInput {
  id: ID
  name: String
}

type TestListResult {
  items: [Test]!
  nextCursor: String
}"
`;

exports[`Test snapshot config js 1`] = `
"directive @test(description: String) on FIELD_DEFINITION | ENUM_VALUE

\\"\\"\\" @model \\"\\"\\"
type Comment {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@manyToOne field: 'comments', key: 'note_id'\\"\\"\\"
  noteComment: Note!
}

input CommentFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [CommentFilterInput]
  or: [CommentFilterInput]
  not: [CommentFilterInput]
}

input CommentInput {
  id: ID
  title: String
  description: String
}

type CommentListResult {
  items: [Comment]!
  nextCursor: String
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID]
  contains: ID
  startsWith: ID
  endsWith: ID
}

type Mutation {
  likeNote(id: ID!): Note!
  createNote(input: NoteInput!): Note!
  updateNote(input: NoteInput!): Note!
  deleteNote(input: NoteInput!): Note!
  createComment(input: CommentInput!): Comment!
  updateComment(input: CommentInput!): Comment!
  deleteComment(input: CommentInput!): Comment!
  createTest(input: TestInput!): Test!
  updateTest(input: TestInput!): Test!
  deleteTest(input: TestInput!): Test!
}

\\"\\"\\" @model \\"\\"\\"
type Note {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@oneToMany field: 'noteComment', key: 'note_id'\\"\\"\\"
  comments(filter: CommentFilterInput): [Comment]!

  \\"\\"\\"@oneToOne key: 'test_id'\\"\\"\\"
  test: Test
}

input NoteFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [NoteFilterInput]
  or: [NoteFilterInput]
  not: [NoteFilterInput]
}

input NoteInput {
  id: ID
  title: String
  description: String
}

type NoteListResult {
  items: [Note]!
  nextCursor: String
}

type Query {
  getLikedNotes(id: ID!, names: [String]!): Note!
  findNote(id: ID!): Note
  findNotes(filter: NoteFilterInput, limit: Int, offset: Int): NoteListResult!
  findAllNotes(filter: NoteFilterInput, limit: Int, offset: Int): [Note!]
  findComment(id: ID!): Comment
  findComments(filter: CommentFilterInput, limit: Int, offset: Int): CommentListResult!
  findAllComments(filter: CommentFilterInput, limit: Int, offset: Int): [Comment!]
  findTest(id: ID!): Test
  findTests(filter: TestFilterInput, limit: Int, offset: Int): TestListResult!
  findAllTests(filter: TestFilterInput, limit: Int, offset: Int): [Test!]
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newNote(input: NoteInput): Note!
  updatedNote(input: NoteInput): Note!
  deletedNote(input: NoteInput): Note!
  newComment(input: CommentInput): Comment!
  updatedComment(input: CommentInput): Comment!
  deletedComment(input: CommentInput): Comment!
  newTest(input: TestInput): Test!
  updatedTest(input: TestInput): Test!
  deletedTest(input: TestInput): Test!
}

\\"\\"\\"@model\\"\\"\\"
type Test {
  id: ID!
  name: String
}

input TestFilterInput {
  id: IDInput
  name: StringInput
  and: [TestFilterInput]
  or: [TestFilterInput]
  not: [TestFilterInput]
}

input TestInput {
  id: ID
  name: String
}

type TestListResult {
  items: [Test]!
  nextCursor: String
}
"
`;

exports[`Test snapshot config ts 1`] = `
"directive @test(description: String) on FIELD_DEFINITION | ENUM_VALUE

\\"\\"\\" @model \\"\\"\\"
type Comment {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@manyToOne field: 'comments', key: 'note_id'\\"\\"\\"
  noteComment: Note!
}

input CommentFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [CommentFilterInput]
  or: [CommentFilterInput]
  not: [CommentFilterInput]
}

input CommentInput {
  id: ID
  title: String
  description: String
}

type CommentListResult {
  items: [Comment]!
  nextCursor: String
}

input IDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  in: [ID]
  contains: ID
  startsWith: ID
  endsWith: ID
}

type Mutation {
  likeNote(id: ID!): Note!
  createNote(input: NoteInput!): Note!
  updateNote(input: NoteInput!): Note!
  deleteNote(input: NoteInput!): Note!
  createComment(input: CommentInput!): Comment!
  updateComment(input: CommentInput!): Comment!
  deleteComment(input: CommentInput!): Comment!
  createTest(input: TestInput!): Test!
  updateTest(input: TestInput!): Test!
  deleteTest(input: TestInput!): Test!
}

\\"\\"\\" @model \\"\\"\\"
type Note {
  id: ID!
  title: String!
  description: String!

  \\"\\"\\"@oneToMany field: 'noteComment', key: 'note_id'\\"\\"\\"
  comments(filter: CommentFilterInput): [Comment]!

  \\"\\"\\"@oneToOne key: 'test_id'\\"\\"\\"
  test: Test
}

input NoteFilterInput {
  id: IDInput
  title: StringInput
  description: StringInput
  and: [NoteFilterInput]
  or: [NoteFilterInput]
  not: [NoteFilterInput]
}

input NoteInput {
  id: ID
  title: String
  description: String
}

type NoteListResult {
  items: [Note]!
  nextCursor: String
}

type Query {
  getLikedNotes(id: ID!, names: [String]!): Note!
  findNote(id: ID!): Note
  findNotes(filter: NoteFilterInput, limit: Int, offset: Int): NoteListResult!
  findAllNotes(filter: NoteFilterInput, limit: Int, offset: Int): [Note!]
  findComment(id: ID!): Comment
  findComments(filter: CommentFilterInput, limit: Int, offset: Int): CommentListResult!
  findAllComments(filter: CommentFilterInput, limit: Int, offset: Int): [Comment!]
  findTest(id: ID!): Test
  findTests(filter: TestFilterInput, limit: Int, offset: Int): TestListResult!
  findAllTests(filter: TestFilterInput, limit: Int, offset: Int): [Test!]
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newNote(input: NoteInput): Note!
  updatedNote(input: NoteInput): Note!
  deletedNote(input: NoteInput): Note!
  newComment(input: CommentInput): Comment!
  updatedComment(input: CommentInput): Comment!
  deletedComment(input: CommentInput): Comment!
  newTest(input: TestInput): Test!
  updatedTest(input: TestInput): Test!
  deletedTest(input: TestInput): Test!
}

\\"\\"\\"@model\\"\\"\\"
type Test {
  id: ID!
  name: String
}

input TestFilterInput {
  id: IDInput
  name: StringInput
  and: [TestFilterInput]
  or: [TestFilterInput]
  not: [TestFilterInput]
}

input TestInput {
  id: ID
  name: String
}

type TestListResult {
  items: [Test]!
  nextCursor: String
}
"
`;
