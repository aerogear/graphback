// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Test plugin engine js 1`] = `
Object {
  "context": Object {
    "fileName": "models.js",
    "output": "const models = [
  {
    name: \\"Note\\",
    pubSub: {
      publishCreate: true,
      publishUpdate: true,
      publishDelete: true,
    },
  },
  {
    name: \\"Comment\\",
    pubSub: {
      publishCreate: true,
      publishUpdate: true,
      publishDelete: true,
    },
  },
]

module.exports = { models }
",
  },
  "resolvers": Object {
    "fileName": "resolvers.js",
    "output": "/*
 * File generated by Graphback CRUD resolver plugin.
 * Content will be overwritten by Graphback generator.
 * To change implementation please disable generator options and supply your own implementation
 * outside generated file.
 */

module.exports = {
  Note: {
    comments: (parent, args, context) => {
      return context.Comment.batchLoadData(\\"noteId\\", parent.id, context)
    },
  },

  Comment: {
    noteComment: (parent, args, context) => {
      return context.Note.findBy({ id: parent.noteId }).then(
        (results) => results[0]
      )
    },
  },

  Query: {
    findNotes: (parent, args, context) => {
      const { filter, ...page } = args
      return context.Note.findBy(filter, page)
    },
    findAllNotes: (parent, args, context) => {
      return context.Note.findAll(args)
    },
    findComments: (parent, args, context) => {
      const { filter, ...page } = args
      return context.Comment.findBy(filter, page)
    },
    findAllComments: (parent, args, context) => {
      return context.Comment.findAll(args)
    },
  },

  Mutation: {
    createNote: (parent, args, context) => {
      return context.Note.create(args.data, context)
    },
    updateNote: (parent, args, context) => {
      return context.Note.update(args.data, context)
    },
    deleteNote: (parent, args, context) => {
      return context.Note.delete(args.data, context)
    },
    createComment: (parent, args, context) => {
      return context.Comment.create(args.data, context)
    },
    updateComment: (parent, args, context) => {
      return context.Comment.update(args.data, context)
    },
    deleteComment: (parent, args, context) => {
      return context.Comment.delete(args.data, context)
    },
  },

  Subscription: {
    newNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToCreate(args, context)
      },
    },
    updatedNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToUpdate(args, context)
      },
    },
    deletedNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToDelete(args, context)
      },
    },
    newComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToCreate(args, context)
      },
    },
    updatedComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToUpdate(args, context)
      },
    },
    deletedComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToDelete(args, context)
      },
    },
  },
}
",
  },
}
`;

exports[`Test plugin engine ts 1`] = `
Object {
  "context": Object {
    "fileName": "models.ts",
    "output": "export const models = [
  {
    name: \\"Note\\",
    pubSub: {
      publishCreate: true,
      publishUpdate: true,
      publishDelete: true,
    },
  },
  {
    name: \\"Comment\\",
    pubSub: {
      publishCreate: true,
      publishUpdate: true,
      publishDelete: true,
    },
  },
]
",
  },
  "resolvers": Object {
    "fileName": "resolvers.ts",
    "output": "/*
 * File generated by Graphback CRUD resolver plugin.
 * Content will be overwritten by Graphback generator.
 * To change implementation please disable generator options and supply your own implementation
 * outside generated file.
 */

export default {
  Note: {
    comments: (parent, args, context) => {
      return context.Comment.batchLoadData(\\"noteId\\", parent.id, context)
    },
  },

  Comment: {
    noteComment: (parent, args, context) => {
      return context.Note.findBy({ id: parent.noteId }).then(
        (results) => results[0]
      )
    },
  },

  Query: {
    findNotes: (parent, args, context) => {
      const { filter, ...page } = args
      return context.Note.findBy(filter, page)
    },
    findAllNotes: (parent, args, context) => {
      return context.Note.findAll(args)
    },
    findComments: (parent, args, context) => {
      const { filter, ...page } = args
      return context.Comment.findBy(filter, page)
    },
    findAllComments: (parent, args, context) => {
      return context.Comment.findAll(args)
    },
  },

  Mutation: {
    createNote: (parent, args, context) => {
      return context.Note.create(args.data, context)
    },
    updateNote: (parent, args, context) => {
      return context.Note.update(args.data, context)
    },
    deleteNote: (parent, args, context) => {
      return context.Note.delete(args.data, context)
    },
    createComment: (parent, args, context) => {
      return context.Comment.create(args.data, context)
    },
    updateComment: (parent, args, context) => {
      return context.Comment.update(args.data, context)
    },
    deleteComment: (parent, args, context) => {
      return context.Comment.delete(args.data, context)
    },
  },

  Subscription: {
    newNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToCreate(args, context)
      },
    },
    updatedNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToUpdate(args, context)
      },
    },
    deletedNote: {
      subscribe: (parent, args, context) => {
        return context.Note.subscribeToDelete(args, context)
      },
    },
    newComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToCreate(args, context)
      },
    },
    updatedComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToUpdate(args, context)
      },
    },
    deletedComment: {
      subscribe: (parent, args, context) => {
        return context.Comment.subscribeToDelete(args, context)
      },
    },
  },
}
",
  },
}
`;
